// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod nylon_http_context {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    pub enum HeaderOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Header<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Header<'a> {
        type Inner = Header<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Header<'a> {
        pub const VT_KEY: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Header { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args HeaderArgs<'args>,
        ) -> flatbuffers::WIPOffset<Header<'bldr>> {
            let mut builder = HeaderBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn key(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_KEY, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn value(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_VALUE, None)
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Header<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, true)?
                .finish();
            Ok(())
        }
    }
    pub struct HeaderArgs<'a> {
        pub key: Option<flatbuffers::WIPOffset<&'a str>>,
        pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for HeaderArgs<'a> {
        #[inline]
        fn default() -> Self {
            HeaderArgs {
                key: None,   // required field
                value: None, // required field
            }
        }
    }

    pub struct HeaderBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HeaderBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_KEY, key);
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_VALUE, value);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> HeaderBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            HeaderBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Header<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Header::VT_KEY, "key");
            self.fbb_.required(o, Header::VT_VALUE, "value");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Header<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Header");
            ds.field("key", &self.key());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum NylonHttpRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NylonHttpRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NylonHttpRequest<'a> {
        type Inner = NylonHttpRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> NylonHttpRequest<'a> {
        pub const VT_METHOD: flatbuffers::VOffsetT = 4;
        pub const VT_PATH: flatbuffers::VOffsetT = 6;
        pub const VT_QUERY: flatbuffers::VOffsetT = 8;
        pub const VT_HEADERS: flatbuffers::VOffsetT = 10;
        pub const VT_BODY: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NylonHttpRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args NylonHttpRequestArgs<'args>,
        ) -> flatbuffers::WIPOffset<NylonHttpRequest<'bldr>> {
            let mut builder = NylonHttpRequestBuilder::new(_fbb);
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            if let Some(x) = args.headers {
                builder.add_headers(x);
            }
            if let Some(x) = args.query {
                builder.add_query(x);
            }
            if let Some(x) = args.path {
                builder.add_path(x);
            }
            if let Some(x) = args.method {
                builder.add_method(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn method(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(NylonHttpRequest::VT_METHOD, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn path(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(NylonHttpRequest::VT_PATH, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn query(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(NylonHttpRequest::VT_QUERY, None)
            }
        }
        #[inline]
        pub fn headers(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Header<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Header>>,
                >>(NylonHttpRequest::VT_HEADERS, None)
            }
        }
        #[inline]
        pub fn body(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        NylonHttpRequest::VT_BODY,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for NylonHttpRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("method", Self::VT_METHOD, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("query", Self::VT_QUERY, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Header>>,
                >>("headers", Self::VT_HEADERS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "body",
                    Self::VT_BODY,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct NylonHttpRequestArgs<'a> {
        pub method: Option<flatbuffers::WIPOffset<&'a str>>,
        pub path: Option<flatbuffers::WIPOffset<&'a str>>,
        pub query: Option<flatbuffers::WIPOffset<&'a str>>,
        pub headers: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Header<'a>>>,
            >,
        >,
        pub body: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for NylonHttpRequestArgs<'a> {
        #[inline]
        fn default() -> Self {
            NylonHttpRequestArgs {
                method: None, // required field
                path: None,   // required field
                query: None,
                headers: None,
                body: None,
            }
        }
    }

    pub struct NylonHttpRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NylonHttpRequestBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_method(&mut self, method: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(NylonHttpRequest::VT_METHOD, method);
        }
        #[inline]
        pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(NylonHttpRequest::VT_PATH, path);
        }
        #[inline]
        pub fn add_query(&mut self, query: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(NylonHttpRequest::VT_QUERY, query);
        }
        #[inline]
        pub fn add_headers(
            &mut self,
            headers: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Header<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                NylonHttpRequest::VT_HEADERS,
                headers,
            );
        }
        #[inline]
        pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(NylonHttpRequest::VT_BODY, body);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> NylonHttpRequestBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            NylonHttpRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NylonHttpRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, NylonHttpRequest::VT_METHOD, "method");
            self.fbb_.required(o, NylonHttpRequest::VT_PATH, "path");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for NylonHttpRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("NylonHttpRequest");
            ds.field("method", &self.method());
            ds.field("path", &self.path());
            ds.field("query", &self.query());
            ds.field("headers", &self.headers());
            ds.field("body", &self.body());
            ds.finish()
        }
    }
    pub enum NylonHttpResponseOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NylonHttpResponse<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NylonHttpResponse<'a> {
        type Inner = NylonHttpResponse<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> NylonHttpResponse<'a> {
        pub const VT_STATUS: flatbuffers::VOffsetT = 4;
        pub const VT_HEADERS: flatbuffers::VOffsetT = 6;
        pub const VT_BODY: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NylonHttpResponse { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args NylonHttpResponseArgs<'args>,
        ) -> flatbuffers::WIPOffset<NylonHttpResponse<'bldr>> {
            let mut builder = NylonHttpResponseBuilder::new(_fbb);
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            if let Some(x) = args.headers {
                builder.add_headers(x);
            }
            builder.add_status(args.status);
            builder.finish()
        }

        #[inline]
        pub fn status(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(NylonHttpResponse::VT_STATUS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn headers(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Header<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Header>>,
                >>(NylonHttpResponse::VT_HEADERS, None)
            }
        }
        #[inline]
        pub fn body(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        NylonHttpResponse::VT_BODY,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for NylonHttpResponse<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("status", Self::VT_STATUS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Header>>,
                >>("headers", Self::VT_HEADERS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "body",
                    Self::VT_BODY,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct NylonHttpResponseArgs<'a> {
        pub status: i32,
        pub headers: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Header<'a>>>,
            >,
        >,
        pub body: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for NylonHttpResponseArgs<'a> {
        #[inline]
        fn default() -> Self {
            NylonHttpResponseArgs {
                status: 0,
                headers: None,
                body: None,
            }
        }
    }

    pub struct NylonHttpResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NylonHttpResponseBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_status(&mut self, status: i32) {
            self.fbb_
                .push_slot::<i32>(NylonHttpResponse::VT_STATUS, status, 0);
        }
        #[inline]
        pub fn add_headers(
            &mut self,
            headers: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Header<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                NylonHttpResponse::VT_HEADERS,
                headers,
            );
        }
        #[inline]
        pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(NylonHttpResponse::VT_BODY, body);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> NylonHttpResponseBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            NylonHttpResponseBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NylonHttpResponse<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for NylonHttpResponse<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("NylonHttpResponse");
            ds.field("status", &self.status());
            ds.field("headers", &self.headers());
            ds.field("body", &self.body());
            ds.finish()
        }
    }
    pub enum NylonHttpContextOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NylonHttpContext<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NylonHttpContext<'a> {
        type Inner = NylonHttpContext<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> NylonHttpContext<'a> {
        pub const VT_END: flatbuffers::VOffsetT = 4;
        pub const VT_REQUEST: flatbuffers::VOffsetT = 6;
        pub const VT_RESPONSE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NylonHttpContext { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args NylonHttpContextArgs<'args>,
        ) -> flatbuffers::WIPOffset<NylonHttpContext<'bldr>> {
            let mut builder = NylonHttpContextBuilder::new(_fbb);
            if let Some(x) = args.response {
                builder.add_response(x);
            }
            if let Some(x) = args.request {
                builder.add_request(x);
            }
            builder.add_end(args.end);
            builder.finish()
        }

        #[inline]
        pub fn end(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(NylonHttpContext::VT_END, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn request(&self) -> NylonHttpRequest<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<NylonHttpRequest>>(
                        NylonHttpContext::VT_REQUEST,
                        None,
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn response(&self) -> NylonHttpResponse<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<NylonHttpResponse>>(
                        NylonHttpContext::VT_RESPONSE,
                        None,
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for NylonHttpContext<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<bool>("end", Self::VT_END, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<NylonHttpRequest>>(
                    "request",
                    Self::VT_REQUEST,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<NylonHttpResponse>>(
                    "response",
                    Self::VT_RESPONSE,
                    true,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct NylonHttpContextArgs<'a> {
        pub end: bool,
        pub request: Option<flatbuffers::WIPOffset<NylonHttpRequest<'a>>>,
        pub response: Option<flatbuffers::WIPOffset<NylonHttpResponse<'a>>>,
    }
    impl<'a> Default for NylonHttpContextArgs<'a> {
        #[inline]
        fn default() -> Self {
            NylonHttpContextArgs {
                end: false,
                request: None,  // required field
                response: None, // required field
            }
        }
    }

    pub struct NylonHttpContextBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NylonHttpContextBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_end(&mut self, end: bool) {
            self.fbb_
                .push_slot::<bool>(NylonHttpContext::VT_END, end, false);
        }
        #[inline]
        pub fn add_request(&mut self, request: flatbuffers::WIPOffset<NylonHttpRequest<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<NylonHttpRequest>>(
                    NylonHttpContext::VT_REQUEST,
                    request,
                );
        }
        #[inline]
        pub fn add_response(&mut self, response: flatbuffers::WIPOffset<NylonHttpResponse<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<NylonHttpResponse>>(
                    NylonHttpContext::VT_RESPONSE,
                    response,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> NylonHttpContextBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            NylonHttpContextBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NylonHttpContext<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, NylonHttpContext::VT_REQUEST, "request");
            self.fbb_
                .required(o, NylonHttpContext::VT_RESPONSE, "response");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for NylonHttpContext<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("NylonHttpContext");
            ds.field("end", &self.end());
            ds.field("request", &self.request());
            ds.field("response", &self.response());
            ds.finish()
        }
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a `NylonHttpContext`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_nylon_http_context_unchecked`.
    pub fn root_as_nylon_http_context(
        buf: &[u8],
    ) -> Result<NylonHttpContext, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<NylonHttpContext>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `NylonHttpContext` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_nylon_http_context_unchecked`.
    pub fn size_prefixed_root_as_nylon_http_context(
        buf: &[u8],
    ) -> Result<NylonHttpContext, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<NylonHttpContext>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `NylonHttpContext` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_nylon_http_context_unchecked`.
    pub fn root_as_nylon_http_context_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<NylonHttpContext<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<NylonHttpContext<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `NylonHttpContext` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_nylon_http_context_unchecked`.
    pub fn size_prefixed_root_as_nylon_http_context_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<NylonHttpContext<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<NylonHttpContext<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a NylonHttpContext and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `NylonHttpContext`.
    pub unsafe fn root_as_nylon_http_context_unchecked(buf: &[u8]) -> NylonHttpContext {
        flatbuffers::root_unchecked::<NylonHttpContext>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed NylonHttpContext and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `NylonHttpContext`.
    pub unsafe fn size_prefixed_root_as_nylon_http_context_unchecked(
        buf: &[u8],
    ) -> NylonHttpContext {
        flatbuffers::size_prefixed_root_unchecked::<NylonHttpContext>(buf)
    }
    #[inline]
    pub fn finish_nylon_http_context_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        root: flatbuffers::WIPOffset<NylonHttpContext<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_nylon_http_context_buffer<
        'a,
        'b,
        A: flatbuffers::Allocator + 'a,
    >(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        root: flatbuffers::WIPOffset<NylonHttpContext<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod nylon_http_context
